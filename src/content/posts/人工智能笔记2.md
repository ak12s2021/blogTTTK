---
title: "人工智能导论-第2章 知识表示"
published: 2024-12-19
tags: []
category: "人工智能导论笔记"
draft: false
---
<h1>第2章 知识表示</h1>
<p>　　•  <strong>知识</strong> 是人工智能最重要的部分，而知识则是由 <strong>概念</strong> 组成。 <strong>概念是人类知识世界的基本单元</strong> 。<br />
• 如果没有<u>对应的概念</u>，那么我们很难甚至不可能将自己的想法表达出来。<br />
• 因此，要想<u>表达知识，能够准确表达概念</u>。</p>
<p>　　‍</p>
<h3>经典概念理论</h3>
<p>　　• 所谓概念的精确定义，就是可以 <strong>给出一个命题</strong> ，亦称为概念的经典定义方法：在这样的概念定义中，对象属于或者不属于这个概念，是一个 <strong>二值问题</strong> 。</p>
<p>　　是/否</p>
<p>　　• 一个经典概念由三部分组成： <strong>概念名、概念的内涵表示、概念的外延表示。</strong></p>
<p>　　◼ 概念名<br />
• 用一个词语来表示，属于符号世界或者认知世界。</p>
<p>　　◼ 概念的内涵表示<br />
• 用命题（非真即假的陈述句）表示；<br />
• 反映和揭示概念的本质属性；<br />
• 是人类主观世界对概念的认知，可存在于人的心智之中，属于心智世界。</p>
<p>　　◼ 概念的外延表示<br />
• 由概念相对应的具体实例组成的集合。</p>
<p>　　经典概念大多隶属于科学概念</p>
<p>　　• 如果我们限定概念都是经典概念，则既可以使用其<strong>内涵表示</strong>进行计算（即所谓的<strong>数理逻辑</strong>），也可以使用其<strong>外延表示</strong>进行计算（对应着<strong>集合论</strong>）</p>
<p>　　‍</p>
<p>　　命题是一个非真即假的陈述句，其真假判断结果称为命题的真值（True 或 False，数理逻辑中用“1”表示真，“0”表示假）</p>
<p>　　简单命题： 不能再分解 的命题；命 题逻辑中的 基本单位。</p>
<p>　　复合命题：通过逻辑 联结词（否定联结词、 合取联结词、析取联 结词、蕴含联结词、 等价联结词等）联结 而成的命题。</p>
<p>　　‍</p>
<h3>数理逻辑之命题逻辑</h3>
<p>　　否定联结词 ﹁</p>
<p>　　等价联结词 $\Leftrightarrow$</p>
<p>　　合取联结词 ∧</p>
<p>　　析取联结词 ∨</p>
<p>　　蕴含联结词 →</p>
<p>　　<u>只有当 p 为真且 q 为假的时候，p→q 才会为假。</u></p>
<p>　　‍</p>
<h2>谓词逻辑</h2>
<p>　　用谓词逻辑即可表示事物的状态、属性和概念等<u>事实性的知识</u>，也可 表示事物间具有因果关系的<u>规则性知识</u>。</p>
<p>　　➢ 用大写英文字母 F，G 等（也可以是多个字母），后跟括号</p>
<p>　　与变元来表示</p>
<p>　　F（x）：x 是人。 G（x,y）：x 和 y 是兄弟。</p>
<p>　　➢ N 元谓词：含有 N 个变元。例如：</p>
<p>　　F（x）是一个一元谓词，G（x,y）是二元谓词。</p>
<p>　　‍</p>
<p>　　量词（quantifier）</p>
<p>　　‍</p>
<p>　　全称量词（universal quantifier）（ $\forall$ x）：“对个体域中的所 有（或任一个）个体 x ”。“所有的”，“全部的” 存在量词（existential quantifier）（ $\exists$ x）：“在个体域中存在 个体 x ”。 “有一些”，“某些的”</p>
<p>　　‍</p>
<p>　　例题 1</p>
<p>　　将下列命题在谓词逻辑中用零元谓词符号化，并讨论其真值。</p>
<p>　　（a）8 是质数；</p>
<p>　　（b）如果 3 大于 4，则 2 大于 6。</p>
<p>　　解：</p>
<p>　　（a）设一元谓词 P(x)为“x 是质数”，则“8 是质数”可符号化为<strong>零元 谓词</strong> P(8)，真值为假。</p>
<p>　　（b）设二元谓词 G(x, y)为“x 大于 y”，则“如果 3 大于 4，则 2 大于 6”符号 化为零元谓词 G(3, 4) ⇒ G(2, 6)，由于 G(3, 4)为假，所以该命题为真。</p>
<p>　　有时将 P(8)、G(3, 4)这样不包含个体变项的谓 词称做零元谓词，当赋予谓词确定含义时零元<br />
谓词为命题。因而可将命题看成是特殊的谓词。</p>
<p>　　将一个用自然语言描述的 命题表示成谓词公式的形式，称为谓词逻辑中的自然语言形式化。 基本方法如下：</p>
<ul>
<li>（1）首先要将问题分解成一些原子命题和逻辑联结符；</li>
<li>（2）之后分解出各个原子命题的个体词、谓词和量词；</li>
<li>（3）按照合式公式的表示规则翻译出自然语句。</li>
</ul>
<p>　　‍</p>
<blockquote>
<p><strong>第一步：分解成原子命题和逻辑联结符</strong></p>
<p>自然语言句子通常包含多个简单的陈述，这些简单的陈述就是原子命题。  逻辑联结符（例如：与、或、非、蕴含、等价）连接这些原子命题，形成复杂的句子结构。  第一步的关键是找出这些原子命题和它们之间的关系。</p>
<p><strong>例子：</strong></p>
<p>“如果今天下雨，而且我带了伞，那么我就不会淋湿。”</p>
<p>我们可以分解成以下原子命题：</p>
<ul>
<li>P: 今天下雨</li>
<li>Q: 我带了伞</li>
<li>R: 我不会淋湿</li>
</ul>
<p>句子中的逻辑关系是：如果 P 且 Q，则 R。  这可以用逻辑联结符表示为：(P ∧ Q) → R</p>
<p><strong>第二步：分解出各个原子命题的个体词、谓词和量词</strong></p>
<p>这一步需要更深入地分析每个原子命题的内部结构。</p>
<ul>
<li><strong>个体词 (Individual Constant/Variable):</strong> <span data-type="text" id="" style="background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);">  </span>代表句子中谈论的对象。 例如，&quot;我&quot;，&quot;今天&quot;，&quot;这把伞&quot;  等。  有时候，个体词可以隐含在句子中，需要我们根据语境补充。</li>
<li><strong>谓词 (Predicate):</strong> <span data-type="text" style="background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);" id="">  </span>描述个体词的性质或个体词之间的关系。  谓词通常是一个动词或形容词，后面跟着括号，括号里是谓词所作用的个体词。</li>
<li><strong>量词 (Quantifier):</strong> <span data-type="text" style="background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);" id="">  </span>表示数量，例如 &quot;所有&quot; (∀)，&quot;存在&quot; (∃)。  量词通常修饰谓词，表示谓词作用于多少个个体。</li>
</ul>
<p>让我们回到之前的例子，并进一步分解：</p>
<ul>
<li>P: 今天下雨  ——  可以表示为  <code>Rain(today)</code>​，其中 <code>Rain</code>​ 是谓词，<code>today</code>​ 是个体词。</li>
<li>Q: 我带了伞  ——  可以表示为 <code>HaveUmbrella(me)</code>​，其中 <code>HaveUmbrella</code>​ 是谓词，<code>me</code>​ 是个体词。</li>
<li>R: 我不会淋湿  ——  可以表示为 <code>NotWet(me)</code>​，其中 <code>NotWet</code>​ 是谓词，<code>me</code>​ 是个体词。</li>
</ul>
<p><strong>第三步：按照合式公式的表示规则翻译出自然语句</strong></p>
<p>将第一步和第二步的结果结合起来，使用谓词逻辑的符号表示整个句子。  这需要遵循谓词逻辑的语法规则，确保公式是合式的。</p>
<p>结合之前的例子，最终的谓词逻辑公式为：</p>
<p>​<code>(Rain(today) ∧ HaveUmbrella(me)) → NotWet(me)</code>​</p>
<p><strong>另一个例子：</strong></p>
<p>“所有的人都喜欢音乐。”</p>
<ul>
<li><strong>原子命题:</strong>   所有的人都喜欢音乐 (这是一个整体，无法再细分)</li>
<li><strong>个体词:</strong>  人 (我们可以用变量 x 代表)</li>
<li><strong>谓词:</strong>  喜欢音乐 (我们可以用 <code>LikesMusic(x)</code>​ 表示)</li>
<li><strong>量词:</strong>  所有 (∀)</li>
</ul>
<p>因此，这个句子的谓词逻辑表示为：</p>
<p>​<code>∀x (Person(x) → LikesMusic(x))</code>​  (这里我们假设 <code>Person(x)</code>​ 表示 x 是人)</p>
<p><strong>总结:</strong></p>
<p>将自然语言形式化成谓词逻辑公式是一个需要仔细分析和理解的过程。  关键在于：</p>
<ol>
<li><strong>识别原子命题和逻辑联结符:</strong>  将复杂的句子分解成简单的陈述及其逻辑关系。</li>
<li><strong>识别个体词、谓词和量词:</strong>   找出句子中描述的对象、性质/关系和数量。</li>
<li><strong>构建合式公式:</strong>   使用谓词逻辑的符号和规则，将所有成分组合成一个合法的公式。</li>
</ol>
</blockquote>
<p>　　‍</p>
<p>　　集合：具有某种特定属性的对象的整体。这些对象称为元素或成员。 ➢ 通常用大写字母表示集合，用小写字母表示元素。 集合的表示方法： ➢ 列举法</p>
<p>　　• 列出集合中的所有元素，花括号中的元素不规定顺序并用逗号隔开。 例如：A={a,b,c} ➢ 描述法</p>
<p>　　• 用谓词 P（x）表示 x 具有性质 P，用{x|P(x)}表示具有性质 P 的集合。 例如：P(x):x 是小写字母 A= {x|P(x)} ={a,b,c,d,e,f,g,h,…,x,y,z}</p>
<p>　　‍</p>
<p>　　‍</p>
<h2>知识的概念</h2>
<p>　　知识：把有关信息关联在一起所形成的信息结构</p>
<p>　　1.相对正确性</p>
<ol start="2">
<li>不确定性</li>
<li>可表示性与可利用性</li>
</ol>
<p>　　‍</p>
<h2>状态空间表示法</h2>
<p>　　❑ 状态空间表示法就是 以 “ 状态空间 ” 的形式 来 表 示问题及其搜索过程的一种方法。</p>
<p>　　❑ 状态空间表示法是人工智能中<u> 最基本的形式化方 法</u>，是讨论问题求解技术的基础。</p>
<p>　　‍</p>
<p>　　<strong>状态空间的四元组表示：(S, O, S₀, G)</strong></p>
<p>　　这个四元组定义了整个问题求解的环境：</p>
<ul>
<li>
<p><strong>S (状态集合):</strong>   这是所有可能状态的集合。  每个状态代表问题在某个时刻的具体情况。  状态通常用状态变量来描述。  状态变量就像问题的“属性”，它们的取值决定了当前的状态。</p>
<ul>
<li><strong>例子:</strong>   考虑一个八数码难题。状态变量可以是九个格子的数字排列。  那么，一个状态就是一个具体的九个数字的排列，例如：<code>[1, 2, 3, 4, 8, 0, 7, 6, 5]</code>​  (其中 0 代表空格)。  S 就包含了所有可能的九个数字排列。</li>
</ul>
</li>
<li>
<p><strong>O (操作算子集):</strong>   这是可以执行的一组操作，这些操作可以将系统从一个状态转换到另一个状态。  操作算子定义了状态之间的转移关系。</p>
<ul>
<li><strong>例子:</strong>   在八数码难题中，操作算子可以是“将空格向上移动”、“将空格向下移动”、“将空格向左移动”、“将空格向右移动”。  每个操作算子都会导致状态的变化。</li>
</ul>
</li>
<li>
<p><strong>S₀ (初始状态):</strong>   这是问题开始时的状态。  它是一个或多个状态的集合，通常只有一个初始状态。</p>
<ul>
<li><strong>例子:</strong>   八数码难题的初始状态可以是 <code>[1, 2, 3, 4, 0, 5, 6, 7, 8]</code>​。</li>
</ul>
</li>
<li>
<p><strong>G (目标状态集合):</strong>   这是我们想要达到的状态，或一组状态。  它可以是一个具体的状态，也可以是一组满足特定条件的状态。</p>
<ul>
<li><strong>例子:</strong>   八数码难题的目标状态可以是 <code>[1, 2, 3, 8, 0, 4, 7, 6, 5]</code>​。</li>
</ul>
</li>
</ul>
<p>　　<strong>状态的描述:</strong></p>
<p>　　状态是问题求解过程中每一步问题状况的数据结构。  它通常用一组数据表示：</p>
<p>　　​<code>S = {S₁, S₂, ...}</code>​</p>
<ul>
<li><strong>状态变量:</strong>   每个 <code>Sᵢ</code>​  都是一个状态，由一组状态变量的值确定。  每个状态变量代表问题的某个属性。  状态变量可以是各种数据类型，例如数字、布尔值、字符串、甚至更复杂的数据结构。</li>
<li><strong>具体状态:</strong>   当每个状态变量都赋予一个确定的值时，就得到一个具体的状态。</li>
<li><strong>数据结构:</strong>   任何类型的数据结构都可以用来描述状态，只要它方便问题求解。  程序中可以使用字符、数字、记录、数组、结构、对象等来表示状态。</li>
</ul>
<p>　　<strong>例子：一个简单的机器人导航问题</strong></p>
<p>　　假设一个机器人在一个 3x3 的网格中移动，目标是到达网格的右下角 (2, 2)。</p>
<ul>
<li><strong>S (状态集合):</strong>   所有可能的机器人位置，可以用坐标 (x, y) 表示，其中 0 ≤ x ≤ 2, 0 ≤ y ≤ 2。</li>
<li><strong>O (操作算子集):</strong>   {向上移动, 向下移动, 向左移动, 向右移动}  (当然，需要考虑边界条件，机器人不能移动到网格之外)。</li>
<li><strong>S₀ (初始状态):</strong>   (0, 0)  (机器人从左上角开始)</li>
<li><strong>G (目标状态集合):</strong>   {(2, 2)}</li>
</ul>
<p>　　<strong>状态空间图:</strong></p>
<p>　　状态空间可以用图来表示，其中节点代表状态，边代表操作算子。  求解问题就相当于在图中寻找从初始状态到目标状态的路径。  搜索算法，例如广度优先搜索、深度优先搜索、A* 搜索等，都可以用来在这个图中寻找路径。</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120007.png" alt="image" />​</p>
<p>　　‍</p>
<p>　　‍</p>
<h2>2.1 产生式表示法</h2>
<p>　　 <strong>产生式通常用于表示事实、 规则以及它 们的不确定性度量， 适合于表示事实性 知识和规则性知识。</strong></p>
<p>　　产生式表示法如今已被应用于很多领 域，成为<u>人工智能中应用最广泛的一种 知识表示方法。</u></p>
<p>　　‍</p>
<ol>
<li>
<p>确定性规则的产生式表示</p>
<p>基本形式： IF P THEN Q</p>
<p>或者： P → Q</p>
<p>意味着： 如果前提 P 被满足，则结论 Q 成立或执行 Q 所规定的操作</p>
<p>‍</p>
</li>
<li>
<p>不确定性规则的产生式表示</p>
<p>基本形式： IF  P THEN Q （置信度）</p>
<p>或者： P → Q （置信度）</p>
<p>例如： IF 发烧 THEN 感冒 （0.6）</p>
</li>
<li>
<p>确定性事实的产生式表示</p>
<p>三元组表示：（对象，属性，值）</p>
<p>或者：（关系，对象 1，对象 2）</p>
<p>例： 老李年龄是 40 岁： （Li，age，40）<br />
老李和老王是朋友：（friend，Li，Wang）</p>
</li>
<li>
<p>不确定性事实的产生式表示</p>
<p>四元组表示：（对象，属性，值，置信度）</p>
<p>或者： （关系，对象 1，对象 2，置信度）</p>
<p>例：老李年龄很可能是 40 岁：（Li，age，40，0.8）</p>
<p>老李和老王不大可能是朋友：（friend，Li，Wang，0.1）</p>
</li>
</ol>
<p>　　‍</p>
<p>　　与蕴含式的主要区别</p>
<p>　　蕴含式表示的知识只能是 <strong>精确</strong> 的，产生式表示的知识可 以是 <strong>不确定</strong> 的。</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120303.png" alt="image" />​</p>
<p>　　▪  <strong>规则库</strong> : 用于描述相应领域内知识的产生式集合。</p>
<p>　　▪  <strong>综合数据库</strong>  (事实库、上下文、黑板等)：一个用于 存放问题求解过程中各种当前信息的数据结构。</p>
<p>　　▪  <strong>控制系统</strong> （推理机构）：由一组程序组成，负责整个 产生式系统的运行，实现对问题的求解。</p>
<p>　　1、推理</p>
<p>　　按一定的策略，从规则库中选择与综合数据库中的已知 事实进行匹配。</p>
<p>　　⚫ 所谓 <strong>匹配</strong> 是指**<u>把规则的前提条件与综合数据库中的已知事实进行比较。</u>**</p>
<p>　　 ⚫ 如果两者一致或者近似一致且满足预先规定的条件，则称</p>
<p>　　匹配成功，相应的规则可被使用；否则称为匹配不成功。</p>
<p>　　2、冲突消解</p>
<p>　　 3、执行规则</p>
<p>　　 4、检查推理终止条件</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120590.png" alt="image" />​</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120971.png" alt="image" />​</p>
<p>　　设已知初始事实存放在综合数据库中： 该动物身上有：暗斑点，长脖子，长腿，奶，蹄</p>
<p>　　‍</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120318.png" alt="image" />​</p>
<p>　　产生式表示法的优点</p>
<ol>
<li>自然性：符合因果形式，是最重要最广泛使用的形式。</li>
<li>模块性：各条规则相互独立。</li>
<li>有效性：即可表示确定性的知识，也可表示启发式知识，又可 表示过程知识。</li>
<li>统一性：规则具有统一的格 式。</li>
</ol>
<p>　　‍</p>
<h3>框架表示法</h3>
<p>　　框架为知识的结构化表达提供了一种自然 的表示方法，即：数据结构。 框架可与过程性知识（产生式规则）结合</p>
<p>　　<strong>框架的核心组成部分:</strong></p>
<p>　　一个框架通常由以下几个部分组成：</p>
<ul>
<li><strong>框架名 (Frame Name):</strong>   框架的标识符，用于区分不同的框架。  例如，“鸟”，“飞机”，“汽车”。</li>
<li><strong>槽 (Slot):</strong>   框架的属性或特征。  每个槽描述了框架的一个方面。  例如，对于“鸟”这个框架，槽可以包括：“颜色”、“翅膀”、“喙”、“叫声”等等。</li>
<li><strong>槽值 (Slot Value):</strong>   槽的具体值。  例如，“颜色”槽的值可以是“蓝色”、“红色”等等。  槽值可以是简单的值（例如，字符串、数字），也可以是更复杂的结构（例如，指向另一个框架的指针）。</li>
<li><strong>默认值 (Default Value):</strong>   槽的预设值，当没有提供特定值时使用。  例如，“鸟”框架的“翅膀”槽的默认值可以是“有”。</li>
<li><strong>继承 (Inheritance):</strong>   框架之间可以存在继承关系。  子框架继承父框架的槽和槽值，并可以添加自己的槽或修改继承的槽值。  例如，“企鹅”框架可以继承“鸟”框架的属性，并添加“不会飞”这样的特殊属性。</li>
<li><strong>过程性知识 (Procedural Attachment):</strong>   框架可以包含过程性知识，例如产生式规则或程序代码，用于处理特定事件或进行推断。  例如，“鸟”框架可以包含一个规则：“如果发现鸟的翅膀受伤，则判断其生存能力降低”。</li>
</ul>
<p>　　<strong>框架表示法的优势:</strong></p>
<ul>
<li><strong>结构化:</strong>   框架以一种结构化的方式组织知识，使得知识易于理解和管理。</li>
<li><strong>层次化:</strong>   框架支持继承机制，可以有效地表示具有层次结构的知识。</li>
<li><strong>默认值:</strong>   默认值机制可以处理不完整信息，提高知识表示的效率。</li>
<li><strong>过程性知识集成:</strong>   框架可以结合过程性知识，实现更复杂的知识推理和应用。</li>
<li><strong>易于理解:</strong>   框架的表示方式直观易懂，方便人们理解和使用。</li>
</ul>
<p>　　<strong>框架表示法的例子:</strong></p>
<p>　　让我们用一个简单的例子来说明框架表示法：</p>
<p>　　假设我们想表示“鸟”和“企鹅”的知识。我们可以使用以下框架：</p>
<p>　　<strong>框架：鸟</strong></p>
<ul>
<li>框架名：鸟</li>
<li>槽：颜色  值：多种颜色（默认值：棕色）</li>
<li>槽：翅膀  值：有（默认值：有）</li>
<li>槽：喙    值：有（默认值：有）</li>
<li>槽：叫声 值：鸣叫（默认值：鸣叫）</li>
<li>槽：飞行能力 值：会飞（默认值：会飞）</li>
</ul>
<p>　　<strong>框架：企鹅</strong></p>
<ul>
<li>框架名：企鹅</li>
<li>继承：鸟</li>
<li>槽：飞行能力 值：不会飞</li>
</ul>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120675.png" alt="image" />​</p>
<p>　　‍</p>
<h4>特点</h4>
<p>　　1.结构性</p>
<p>　　2.继承性</p>
<p>　　3.自然性</p>
<p>　　‍</p>
<h3>2.3 问题归约表示</h3>
<p>　　问题归约表示法的三个核心组成部分和其实质。</p>
<p>　　 <strong>(1) 初始问题描述:</strong></p>
<p>　　这是整个问题归约过程的起点。 它清晰、完整地描述了需要解决的问题。  这个描述必须足够精确，以便能够确定问题是否已被解决，以及如何将它分解成子问题。  它可以是自然语言描述，也可以是更形式化的描述，例如数学公式或逻辑表达式。  关键在于，它必须无歧义地定义了目标状态。</p>
<p>　　<strong>例子:</strong>   “将 100 个物品装进尽可能少的箱子中，每个箱子的最大容量是 20。”</p>
<p>　　 <strong>(2) 一套把问题变换为子问题的操作符:</strong></p>
<p>　　这套操作符定义了如何将一个问题分解成更小的子问题。  它们是问题分解的核心机制。  这些操作符可以是：</p>
<ul>
<li><strong>函数:</strong>   将一个问题作为输入，并返回一个或多个子问题。</li>
<li><strong>规则:</strong>   描述在什么条件下，一个问题可以被分解成哪些子问题。</li>
<li><strong>算法:</strong>   一个更复杂的算法，用于确定如何最佳地分解问题。</li>
</ul>
<p>　　这些操作符必须是有效的，也就是说，它们必须能够将问题分解成更简单的子问题，并且这些子问题的解能够组合起来得到原始问题的解。</p>
<p>　　<strong>例子:</strong>   对于装箱问题，操作符可以是：“选择一个物品，尝试将其放入已有的箱子中，如果放不下，则创建一个新的箱子”。</p>
<p>　　 <strong>(3) 一套本原问题描述:</strong></p>
<p>　　这些是简单到可以直接求解的问题。  它们是问题归约过程的终点。  本原问题通常非常简单，可以直接给出答案，不需要进一步分解。  它们代表了问题分解的基准。</p>
<p>　　<strong>例子:</strong>   对于装箱问题，本原问题可以是：“只有一个物品需要装箱”。  这个本原问题很容易解决：只需要创建一个箱子，并将物品放入其中。</p>
<p>　　<strong>问题归约的实质：逆向推理</strong></p>
<p>　　问题归约的实质是从目标（初始问题）出发，逆向推理，逐步分解问题。  这个过程就像构建一棵树，初始问题是树根，子问题是树枝，本原问题是树叶。  通过逆向推理，我们构建了从初始问题到本原问题的路径，然后通过正向求解本原问题，并逐步组合它们的解，最终得到初始问题的解。  这是一种自顶向下的策略。</p>
<p>　　‍</p>
<h3>2.4 语义网络法</h3>
<p>　　语义网络的核心组成部分是：</p>
<ul>
<li><strong>节点 (Node):</strong>   代表概念或实体。  例如，“狗”、“猫”、“动物”、“颜色”、“红色”等等。  节点可以是具体的个体，也可以是抽象的概念。</li>
<li><strong>边 (Edge):</strong>   代表概念之间的关系。  边通常用一个标签来表示关系的类型。  例如，“is-a”（属于）、“has-part”（具有部分）、“has-property”（具有属性）、“located-in”（位于）等等。</li>
</ul>
<p>　　例 用一个语义网络表示下列命题。</p>
<p>　　(1) 树和草都是植物；</p>
<p>　　(2) 树和草是有根有叶的；</p>
<p>　　(3) 水草是草，且长在水中；</p>
<p>　　(4) 果树是树，且会结果；</p>
<p>　　(5) 苹果树是果树中的一种，它结苹果。</p>
<p>　　‍</p>
<p>　　‍</p>
<p>　　分析： 问题涉及的对象有： 植物、树、草、水草、果树、苹果树</p>
<p>　　 各对象的属性分别为：</p>
<p>　　树和草的属性：有根、有叶；</p>
<p>　　 水草的属性：长在水中；</p>
<p>　　果树的属性：会结果；</p>
<p>　　苹果树的属性：结苹果。</p>
<p>​<img src="https://cbt567.oss-rg-china-mainland.aliyuncs.com/img/202412192120985.png" alt="image" />​</p>
<p>　　<strong>例子:</strong></p>
<p>　　考虑一个简单的语义网络，表示“一只红色的狗”。  它可以表示为：</p>
<pre><code>狗 --is-a--> 动物
狗 --has-property--> 颜色
颜色 --is-a--> 红色
</code></pre>
<p>　　在这个例子中，“狗”、“动物”、“颜色”、“红色”都是节点，“is-a”和“has-property”是边。</p>
<p>　　<strong>语义网络的优点:</strong></p>
<ul>
<li><strong>直观性:</strong>   语义网络的图结构非常直观，易于理解和使用。</li>
<li><strong>表达能力:</strong>   语义网络能够表达多种类型的知识，包括事实、规则和概念之间的关系。</li>
<li><strong>可扩展性:</strong>   语义网络可以很容易地扩展，以包含新的概念和关系。</li>
<li><strong>易于推理:</strong>   一些简单的推理任务，例如继承和匹配，在语义网络上很容易实现。</li>
</ul>
<p>　　<strong>语义网络的缺点:</strong></p>
<ul>
<li><strong>表达能力的局限性:</strong>   语义网络在表达复杂的逻辑关系和不确定性方面存在局限性。  它难以表达否定、蕴含等复杂的逻辑关系。</li>
<li><strong>语义歧义:</strong>   关系标签的含义可能存在歧义，需要仔细定义。  例如，“has-part”关系在不同的上下文中可能具有不同的含义。</li>
<li><strong>知识冗余:</strong>   语义网络中可能存在知识冗余，因为相同的信息可能在多个地方重复出现。</li>
<li><strong>缺乏形式化:</strong>   语义网络通常缺乏形式化的语义，这使得难以进行严格的逻辑推理。</li>
</ul>
<p>　　<strong>语义网络的应用:</strong></p>
<p>　　语义网络广泛应用于各种领域，包括：</p>
<ul>
<li><strong>自然语言处理:</strong>   用于理解自然语言文本的语义。</li>
<li><strong>知识工程:</strong>   用于构建知识库和专家系统。</li>
<li><strong>信息检索:</strong>   用于改进信息检索的效率和准确性。</li>
<li><strong>本体工程:</strong>   用于构建本体，描述特定领域的概念和关系。</li>
</ul>
<p>　　<strong>语义网络的改进:</strong></p>
<p>　　为了克服语义网络的局限性，人们提出了一些改进方法，例如：</p>
<ul>
<li><strong>引入更丰富的关系类型:</strong>   使用更精细的关系类型来表达更复杂的语义。</li>
<li><strong>使用逻辑语言:</strong>   将语义网络与逻辑语言结合起来，提高表达能力和推理能力。</li>
<li><strong>引入不确定性:</strong>   在语义网络中引入不确定性表示，以处理不确定性知识。</li>
</ul>
<p>　　‍</p>
