---
title: "c++大复习"
published: 2024-12-19
tags: []
category: "未分类"
draft: false
---
<h1>c++大复习</h1>
<h1>CH1</h1>
<h2>构造函数和初始化</h2>
<p>　　你提到的 <code>public: int x, y;</code>​ 确实在类中声明了成员变量 <code>x</code>​ 和 <code>y</code>​。但这并不意味着它们在对象创建时会被自动初始化。让我们详细讨论一下这一点。</p>
<h3>1. 声明与初始化的区别</h3>
<ul>
<li><strong>声明</strong>：<code>int x, y;</code>​ 只是声明了变量，这意味着类的每个对象将包含两个整型变量 <code>x</code>​ 和 <code>y</code>​。但是，C++ 不会自动给这些变量赋初始值。</li>
<li><strong>默认值</strong>：如果你没有定义构造函数，<code>x</code>​ 和 <code>y</code>​ 的值将是未定义的，这可能导致不可预测的行为。</li>
</ul>
<h3>2. 构造函数的作用</h3>
<p>　　构造函数的主要作用是确保在对象创建时对成员变量进行初始化。构造函数可以：</p>
<ul>
<li><strong>指定初始值</strong>：通过构造函数，你可以为 <code>x</code>​ 和 <code>y</code>​ 指定明确的初始值。</li>
<li><strong>提供灵活性</strong>：你可以定义多个构造函数，允许不同的初始化方式。</li>
</ul>
<h3>3. 示例</h3>
<p>　　考虑下面的例子：</p>
<pre><code class="language-cpp">class Point {
public:
    int x, y; // 仅声明，不初始化

    // 默认构造函数
    Point() {
        x = 0; // 初始化为0
        y = 0; // 初始化为0
    }

    // 带参数的构造函数
    Point(int a, int b) {
        x = a; // 使用参数初始化
        y = b; // 使用参数初始化
    }
};

int main() {
    Point p1; // 使用默认构造函数，x和y被初始化为0
    Point p2(10, 20); // 使用带参数的构造函数，x为10，y为20

    std::cout << &quot;p1: (&quot; << p1.x << &quot;, &quot; << p1.y << &quot;)&quot; << std::endl; // 输出: p1: (0, 0)
    std::cout << &quot;p2: (&quot; << p2.x << &quot;, &quot; << p2.y << &quot;)&quot; << std::endl; // 输出: p2: (10, 20)

    return 0;
}
</code></pre>
<p>　　‍</p>
<h2>作用域和析构函数</h2>
<p>　　在 C++ 中，<strong>作用域</strong>是指一个变量的可见性和生命周期的范围。当一个变量超出其作用域时，该变量会被销毁，相关的资源也会被释放。对于类的对象，析构函数会在对象的生命周期结束时自动调用。下面详细解释这个过程。</p>
<h3>1. 什么是作用域？</h3>
<ul>
<li>
<p><strong>作用域</strong>指的是变量的可见范围。在 C++ 中，常见的作用域有：</p>
<ul>
<li><strong>全局作用域</strong>：在所有函数外部定义的变量。</li>
<li><strong>局部作用域</strong>：在函数或代码块内部定义的变量。</li>
</ul>
</li>
</ul>
<h3>2. 对象的生命周期</h3>
<ul>
<li>当你在某个作用域内创建一个对象（比如在函数内部），这个对象的生命周期与这个作用域相关联。</li>
<li>当程序执行到作用域的结束（例如函数返回，或者代码块结束）时，所有在该作用域内创建的局部变量（包括对象）会被销毁。</li>
</ul>
<h3>3. 析构函数的自动调用</h3>
<ul>
<li>当对象超出作用域时，C++ 会自动调用该对象的析构函数，以执行清理操作（如释放内存、关闭文件等）。</li>
<li>这个过程是由 C++ 的内存管理机制自动处理的，程序员不需要手动调用析构函数。</li>
<li>‍</li>
</ul>
<h3>示例</h3>
<p>　　考虑以下代码示例：</p>
<pre><code class="language-cpp">#include <iostream>
using namespace std;

class Buffer {
public:
    int* data;

    // 构造函数
    Buffer(int size) {
        data = new int[size]; // 动态分配内存
        cout << &quot;Buffer allocated.&quot; << endl;
    }

    // 析构函数
    ~Buffer() {
        delete[] data; // 释放分配的内存
        cout << &quot;Buffer deallocated.&quot; << endl;
    }
};

void createBuffer() {
    Buffer buf(10); // 在局部作用域内创建对象
    // buf在这里被创建并使用
    // 当函数结束时，buf将超出作用域
}

int main() {
    createBuffer(); // 调用函数
    // 一旦createBuffer函数结束，buf超出作用域，析构函数自动调用
    return 0;
}
</code></pre>
<h3>解释</h3>
<ul>
<li>在这个例子中，<code>Buffer buf(10);</code>​ 在 <code>createBuffer</code>​ 函数的局部作用域内创建。</li>
<li>当 <code>createBuffer</code>​ 函数执行完毕后，它的作用域结束，局部变量 <code>buf</code>​ 也随之超出作用域。</li>
<li>这时，C++ 会自动调用 <code>Buffer</code>​ 类的析构函数，输出 <code>Buffer deallocated.</code>​，并释放 <code>data</code>​ 指向的内存。</li>
</ul>
<h3>总结</h3>
<ul>
<li><strong>超出作用域</strong>指的是对象生命周期结束，通常发生在函数返回或代码块结束时。</li>
<li><strong>自动调用析构函数</strong>是 C++ 内存管理的一部分，确保对象在生命周期结束时正确释放资源。</li>
</ul>
<p>　　‍</p>
<h2>cin 与 getline</h2>
<h3>1. <code>getline(cin, str)</code>​</h3>
<ul>
<li>
<p><strong>使用</strong>：这是一个标准库函数，用于读取一整行输入，直到遇到换行符（<code>\n</code>​）。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li>​<code>cin</code>​：输入流。</li>
<li>​<code>str</code>​：用于存储读取到的字符串的标准字符串对象（<code>std::string</code>​）。</li>
</ul>
</li>
<li>
<p><strong>特性</strong>：</p>
<ul>
<li>​<code>getline</code>​ 会自动处理换行符，读取的字符串不包括换行符。</li>
<li>它会动态调整存储的大小，适合读取任意长度的字符串。</li>
</ul>
</li>
</ul>
<p>　　<strong>示例</strong>：</p>
<pre><code class="language-cpp">#include <iostream>
#include <string>
using namespace std;

int main() {
    string str;
    cout << &quot;Enter a line: &quot;;
    getline(cin, str); // 读取整行
    cout << &quot;You entered: &quot; << str << endl;
    return 0;
}
</code></pre>
<h3>2. <code>cin.getline(str, 50)</code>​</h3>
<ul>
<li>
<p><strong>使用</strong>：这是 <code>istream</code>​ 类的成员函数，用于从输入流中读取固定长度的字符。</p>
</li>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li>​<code>str</code>​：用于存储读取到的字符串的字符数组（<code>char[]</code>​）。</li>
<li>​<code>50</code>​：指定读取的最大字符数（包括结束符）。</li>
</ul>
</li>
<li>
<p><strong>特性</strong>：</p>
<ul>
<li>如果输入超过指定长度，<code>getline</code>​ 将截断输入，并将剩余部分留在输入流中。</li>
<li>读取的字符串会以 null 字符（<code>\0</code>​）结束。</li>
<li>如果输入的字符数不足，<code>str</code>​ 会以 null 字符结束。</li>
</ul>
</li>
</ul>
<p>　　<strong>示例</strong>：</p>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code class="language-c">#include <iostream>
using namespace std;

int main() {
    char str[50];
    cout << &quot;Enter a line: &quot;;
    cin.getline(str, 50); // 读取最多49个字符
    cout << &quot;You entered: &quot; << str << endl;
    return 0;
}
</code></pre>
<h3>3. 总结</h3>
<ul>
<li>
<p>​<strong>​<code>getline(cin, str)</code>​</strong> ​：</p>
<ul>
<li>用于读取 <code>std::string</code>​ 类型，适合处理动态大小的字符串。</li>
<li>读取整行输入，自动处理换行符。</li>
</ul>
</li>
<li>
<p>​<strong>​<code>cin.getline(str, 50)</code>​</strong> ​：</p>
<ul>
<li>用于读取 <code>char</code>​ 数组，适合处理固定大小的字符串。</li>
<li>需手动指定最大字符数，且可能会截断输入。</li>
</ul>
</li>
</ul>
<h3>使用场景</h3>
<ul>
<li>使用 <code>getline</code>​ 更为常见，特别是在处理用户输入时，因为它更灵活且易于使用。</li>
<li>使用 <code>cin.getline</code>​ 适合在需要限制输入长度的情况下，例如处理固定大小的字符数组。</li>
</ul>
<p>　　‍</p>
<h2>操作符重载</h2>
<p>　　操作符重载是 C++ 的一种特性，允许开发者为自定义类型（类）定义或修改已有操作符的行为。通过操作符重载，你可以使得自定义类型的对象像内置类型一样使用操作符，例如 <code>+</code>​、<code>-</code>​、<code>*</code>​、<code><<</code>​ 和 <code>>></code>​ 等。</p>
<h3>1. 操作符重载的基本规则</h3>
<ul>
<li><strong>语法</strong>：操作符重载可以通过成员函数或友元函数实现。成员函数的第一个参数是 <code>this</code> ​指针，表示调用该操作符的对象；而友元函数则需要接受两个对象作为参数。</li>
<li><strong>返回值</strong>：通常返回一个新的对象，表示操作的结果。</li>
</ul>
<h3>2. 示例：重载加法运算符 (<code>+</code>​)</h3>
<p>　　下面是一个简单的示例，演示如何重载加法运算符：</p>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code class="language-c">#include <iostream>
using namespace std;

class Complex {
private:
    double real;
    double imag;

public:
    // 构造函数
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 操作符重载：加法
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }

    // 输出重载
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << c.real << &quot; + &quot; << c.imag << &quot;i&quot;;
        return os;
    }
};

int main() {
    Complex c1(1.5, 2.5);
    Complex c2(3.5, 4.5);
    Complex c3 = c1 + c2; // 使用重载的加法运算符

    cout << &quot;Result: &quot; << c3 << endl; // 输出: Result: 5 + 7i
    return 0;
}
</code></pre>
<h3>3. 常见的操作符重载</h3>
<p>　　以下是一些常见的可以重载的操作符：</p>
<ul>
<li>算术运算符：<code>+</code>​, <code>-</code>​, <code>*</code>​, <code>/</code>​</li>
<li>关系运算符：<code>==</code>​, <code>!=</code>​, <code><</code>​, <code>></code>​, <code><=</code>​, <code>>=</code>​</li>
<li>逻辑运算符：<code>&&</code>​, <code>||</code>​, <code>!</code>​</li>
<li>位运算符：<code>&</code>​, <code>|</code>​, <code>^</code>​, <code><<</code>​, <code>>></code>​</li>
<li>索引运算符：<code>[]</code>​</li>
<li>函数调用运算符：<code>()</code>​</li>
<li>自增/自减运算符：<code>++</code>​, <code>--</code>​</li>
</ul>
<h2>继承</h2>
<p>　　继承是面向对象编程（OOP）中的一个重要概念，允许一个类（称为子类或派生类）从另一个类（称为父类或基类）“继承”属性和方法。继承使得代码重用成为可能，并提供了一种建立类之间关系的方式。</p>
<h3>1. 基本概念</h3>
<ul>
<li><strong>基类（父类）</strong> ：提供属性和方法的类。</li>
<li><strong>派生类（子类）</strong> ：从基类继承属性和方法的类，可以添加新属性和方法，或重写基类的方法。</li>
</ul>
<h3>2. 继承的好处</h3>
<ul>
<li><strong>代码重用</strong>：通过继承，子类可以重用父类的代码，减少重复。</li>
<li><strong>扩展性</strong>：可以在子类中添加新功能，而不需要修改基类。</li>
<li><strong>多态性</strong>：通过基类指针或引用可以指向派生类对象，允许在运行时决定调用哪个类的方法。</li>
</ul>
<h3>3. 继承的语法</h3>
<p>　　在 C++ 中，使用冒号（<code>:</code>​）来表示继承关系。基本语法如下：</p>
<pre><code class="language-cpp">class DerivedClass : public BaseClass {
    // 子类的成员
};
</code></pre>
<h3>4. 示例</h3>
<p>　　以下是一个简单的例子，展示了继承的用法：</p>
<pre><code class="language-cpp">#include <iostream>
using namespace std;

// 基类
class Animal {
public:
    void speak() {
        cout << &quot;Animal speaks&quot; << endl;
    }
};

// 派生类
class Dog : public Animal {
public:
    void bark() {
        cout << &quot;Dog barks&quot; << endl;
    }
};

int main() {
    Dog dog;
    dog.speak(); // 调用基类的方法
    dog.bark();  // 调用子类的方法

    return 0;
}
</code></pre>
<h3>5. 访问控制</h3>
<p>　　在 C++ 中，继承还可以通过访问控制符（<code>public</code>​、<code>protected</code>​、<code>private</code>​）来控制基类成员在派生类中的可见性：</p>
<ul>
<li><strong>public</strong> 继承：基类的 public 成员在派生类中仍然是 public。</li>
<li><strong>protected</strong> 继承：基类的 public 和 protected 成员在派生类中变为 protected。</li>
<li><strong>private</strong> 继承：基类的 public 和 protected 成员在派生类中变为 private。</li>
</ul>
<h3>6. 多重继承</h3>
<p>　　C++ 支持多重继承，即一个类可以继承多个基类：</p>
<pre><code class="language-cpp">class ClassA {};
class ClassB {};
class Derived : public ClassA, public ClassB {};
</code></pre>
<h3>7. 总结</h3>
<ul>
<li><strong>继承</strong>允许创建新类时重用已有类的代码，提供了代码组织和扩展的灵活性。</li>
<li>基类和派生类之间的关系使得可以建立更复杂的类层次结构，促进代码的可重用性和可读性。</li>
</ul>
<p>　　‍</p>
<h2>多态性和虚拟函数</h2>
<h3>1. 多态性</h3>
<p>　　<strong>多态性</strong>（Polymorphism）指的是同一个操作（方法或函数）可以作用于不同类型的对象，并产生不同的结果。在 C++ 中，多态性主要分为两种类型：</p>
<ul>
<li><strong>编译时多态性</strong>（静态多态性）：通过函数重载和运算符重载实现。</li>
<li><strong>运行时多态性</strong>（动态多态性）：通过虚拟函数和继承实现。</li>
</ul>
<h3>2. 虚拟函数</h3>
<p>　　<strong>虚拟函数</strong>（Virtual Functions）是 C++ 中的一种机制，用于实现运行时多态性。虚拟函数允许在基类中声明一个函数，并在派生类中重写（override）该函数。通过基类指针或引用调用虚拟函数时，会根据实际对象的类型决定调用哪个版本的函数。</p>
<h4>虚拟函数的特点</h4>
<ul>
<li>在基类中使用 <code>virtual</code>​ 关键字声明。</li>
<li>在派生类中可以重写虚拟函数。</li>
<li>通过基类指针或引用调用虚拟函数时，会执行实际对象的函数，而不是指针或引用的类型所指向的函数。</li>
</ul>
<h3>3. 示例代码</h3>
<p>　　以下是一个使用虚拟函数实现多态性的示例：</p>
<pre><code class="language-cpp">#include <iostream>
using namespace std;

// 基类
class Animal {
public:
    virtual void speak() { // 声明虚拟函数
        cout << &quot;Animal speaks&quot; << endl;
    }
};

// 派生类1
class Dog : public Animal {
public:
    void speak() override { // 重写虚拟函数
        cout << &quot;Dog barks&quot; << endl;
    }
};

// 派生类2
class Cat : public Animal {
public:
    void speak() override { // 重写虚拟函数
        cout << &quot;Cat meows&quot; << endl;
    }
};

int main() {
    Animal* animal1 = new Dog(); // 基类指针指向派生类对象
    Animal* animal2 = new Cat(); // 基类指针指向另一个派生类对象

    animal1->speak(); // 输出: Dog barks
    animal2->speak(); // 输出: Cat meows

    delete animal1; // 释放内存
    delete animal2; // 释放内存

    return 0;
}
</code></pre>
<h3>4. 代码解释</h3>
<ul>
<li>
<p><strong>基类</strong> <strong>​<code>Animal</code>​</strong>​：</p>
<ul>
<li>定义了一个虚拟函数 <code>speak()</code>​，表示动物的叫声。</li>
</ul>
</li>
<li>
<p><strong>派生类</strong> <strong>​<code>Dog</code>​</strong>​ <strong>和</strong> <strong>​<code>Cat</code>​</strong>​：</p>
<ul>
<li>分别重写了 <code>speak()</code>​ 函数，提供各自的实现。</li>
</ul>
</li>
<li>
<p><strong>主函数</strong> <strong>​<code>main</code>​</strong>​：</p>
<ul>
<li>创建了 <code>Animal</code>​ 类型的指针，分别指向 <code>Dog</code>​ 和 <code>Cat</code>​ 对象。</li>
<li>调用 <code>speak()</code>​ 函数时，程序根据指针实际指向的对象类型执行对应的函数，表现出多态性。</li>
</ul>
</li>
</ul>
<h3>5. 总结</h3>
<ul>
<li><strong>多态性</strong>使得同一操作可以作用于不同类型的对象，提高了代码的灵活性和可扩展性。</li>
<li><strong>虚拟函数</strong>是实现运行时多态性的关键机制，允许在基类中定义接口，并在派生类中提供具体实现。</li>
</ul>
<p>　　在 C++ 中，即使派生类重写了基类的虚拟函数，基类仍然需要定义该函数。这样做有几个重要的理由：</p>
<h3>1. 提供默认行为</h3>
<p>　　在基类中定义虚拟函数可以提供一个<strong>默认实现</strong>。这样，如果某个派生类没有重写这个函数，仍然可以调用基类的实现。这在某些情况下是非常有用的，比如：</p>
<ul>
<li><strong>简单派生类</strong>：有些派生类可能不需要提供特定的实现，直接使用基类的默认行为即可。</li>
<li><strong>调试</strong>：在调试时，可以使用基类的实现来检查调用流程。</li>
</ul>
<h3>2. 确保接口一致性</h3>
<p>　　通过在基类中定义虚拟函数，可以确保所有派生类都有相同的接口。这种一致性使得代码更易于理解和维护。例如，如果你有一个函数接受基类指针或引用作为参数，它可以调用 <code>speak()</code>​ 方法，而不需要知道具体是哪种动物：</p>
<pre><code class="language-cpp">void makeAnimalSpeak(Animal* animal) {
    animal->speak(); // 调用基类的接口
}
</code></pre>
<h3>3. 实现多态性</h3>
<p>　　虚拟函数的存在使得多态性得以实现。通过基类指针或引用调用虚拟函数时，会根据实际对象的类型决定调用哪个实现。即使派生类重写了该函数，基类中仍然定义的虚拟函数是多态机制的一部分。</p>
<p>　　‍</p>
<h2>非静态成员函数</h2>
<p>　　非静态成员函数是属于类的实例（对象）的函数，而不是属于类本身的函数。以下是一些关键点：</p>
<ol>
<li>
<p><strong>与对象关联</strong>：非静态成员函数需要通过对象来调用。这意味着它们可以访问该对象的非静态成员变量和其他非静态成员函数。</p>
</li>
<li>
<p><strong>隐式参数</strong>：在非静态成员函数中，隐式地有一个指向调用该函数的对象的指针（通常是 <code>this</code>​ 指针），允许函数访问该对象的属性和其他方法。</p>
</li>
<li>
<p><strong>实例化</strong>：要调用非静态成员函数，必须先创建类的实例。例如：</p>
<pre><code class="language-cpp">class MyClass {
public:
    void MyFunction() {
        // 访问对象的成员变量
    }
};

MyClass obj; // 创建对象
obj.MyFunction(); // 调用非静态成员函数
</code></pre>
</li>
<li>
<p><strong>与静态成员函数的区别</strong>：静态成员函数属于类本身，可以直接通过类名调用，而不需要创建对象。静态成员函数不能访问非静态成员变量或非静态成员函数。</p>
</li>
</ol>
<p>　　非静态成员函数通常用于需要操作特定对象状态的场景。</p>
<p>　　‍</p>
<h3>为什么虚函数必须是非静态的？</h3>
<ol>
<li>
<p><strong>非静态成员函数</strong>：</p>
<ul>
<li>非静态成员函数是与对象实例相关联的。它们可以访问该对象的成员变量（使用 <code>this</code>​ 指针）。</li>
<li>当你创建一个对象时，可以通过这个对象调用它的成员函数。</li>
</ul>
</li>
<li>
<p><strong>静态成员函数</strong>：</p>
<ul>
<li>静态成员函数是与类本身相关联的，而不是与任何特定的对象实例相关联。</li>
<li>静态函数不能使用 <code>this</code>​ 指针，因为它们不属于任何对象。</li>
<li>由于没有 <code>this</code>​ 指针，静态成员函数无法访问对象的实例数据，也不能实现多态性。</li>
</ul>
</li>
</ol>
<h2>作用域解析运算符：：</h2>
<p>　　​<code>::</code>​ 是作用域解析运算符（scope resolution operator），用于指定标识符的作用域。它有几个主要用途：</p>
<ol>
<li>
<p><strong>访问类的成员</strong>：用于访问类中的静态成员或嵌套类。例如：</p>
<pre><code class="language-cpp">class MyClass {
public:
    static int value;
};

int MyClass::value = 10; // 定义静态成员
</code></pre>
</li>
<li>
<p><strong>访问命名空间中的成员</strong>：用于访问特定命名空间中的变量或函数。例如：</p>
<pre><code class="language-cpp">namespace MyNamespace {
    void MyFunction() {
        // ...
    }
}

MyNamespace::MyFunction(); // 调用命名空间中的函数
</code></pre>
</li>
<li>
<p><strong>全局作用域</strong>：在全局作用域中使用 <code>::</code>​ 可以访问全局变量或函数，避免与局部作用域中的同名标识符冲突。例如：</p>
<pre><code class="language-cpp">int value = 5; // 全局变量

void MyFunction() {
    int value = 10; // 局部变量
    std::cout << ::value; // 输出全局变量
}
</code></pre>
</li>
<li>
<p><strong>类的构造函数和析构函数</strong>：在定义类的构造函数和析构函数时，使用 <code>::</code>​ 来指定它们属于哪个类。例如：<br />
cpp</p>
<p>Copy</p>
<pre><code class="language-cpp">class MyClass {
public:
    MyClass() { /* 构造函数 */ }
    ~MyClass() { /* 析构函数 */ }
};

MyClass::MyClass() { /* 实现 */ } // 实现构造函数
</code></pre>
</li>
</ol>
<p>　　通过使用 <code>::</code>​ 运算符，可以明确指明所引用的标识符的作用域，避免歧义。</p>
<h2>new</h2>
<h3>1. <strong>不使用</strong> <strong>​<code>new</code>​</strong>​ <strong>的情况</strong></h3>
<ul>
<li><strong>栈上分配</strong>：如果在 <code>example()</code>​ 函数中声明一个 <code>Son</code>​ 对象，比如 <code>Son A;</code>​，这个对象存储在栈上。</li>
<li><strong>作用域</strong>：当 <code>example()</code>​ 函数执行完毕时，<code>A</code>​ 的生命周期结束，资源会自动释放。此时，<code>A</code>​ 不能再在 <code>main()</code>​ 函数中访问或修改，因为它已经被销毁了。</li>
</ul>
<h3>2. <strong>使用</strong> <strong>​<code>new</code>​</strong>​ <strong>的情况</strong></h3>
<ul>
<li><strong>堆上分配</strong>：如果使用 <code>new</code>​ 创建对象，比如 <code>Son* B = new Son();</code>​，这个对象存储在堆内存中。</li>
<li><strong>持续存在</strong>：堆上的对象在程序运行时存在，直到显式调用 <code>delete</code>​。这样，即使在 <code>example()</code>​ 函数结束后，你仍然可以通过指针在 <code>main()</code>​ 函数中访问和修改这个对象。</li>
</ul>
<h3>示例代码</h3>
<pre><code class="language-cpp">#include <iostream>

class Son {
public:
    void show() { std::cout << &quot;Son object\n&quot;; }
};

void example() {
    Son A; // 在栈上创建，生命周期仅限于 example 函数
    A.show(); // 可以在这里调用
    // A 的生命周期结束后，自动被销毁
  
    Son* B = new Son(); // 在堆上创建，生命周期由手动管理
    B->show(); // 在这里调用
    // 注意：B 需要在不再使用时手动 delete
}

int main() {
    example();
  
    // 这里不能访问 A，因为它已经被销毁
    // A.show(); // 错误，A 不再有效

    Son* B = new Son(); // 重新在 main 中创建
    B->show(); // 可以调用
    delete B; // 释放内存

    return 0;
}
</code></pre>
<h3>总结</h3>
<ul>
<li><strong>不加</strong> <strong>​<code>new</code>​</strong>​：对象只能在其创建的函数中使用，超出作用域后自动销毁。</li>
<li><strong>加</strong> <strong>​<code>new</code>​</strong>​：对象可以在多个函数中使用，直到显式释放内存，允许更灵活的内存管理。</li>
</ul>
<h3>1. 静态成员的特性</h3>
<ul>
<li><strong>静态成员变量</strong> 是属于类本身的，而不是属于某个具体的对象。这意味着它们在内存中的存储是全局的，所有对象共享同一份数据。</li>
<li>静态成员变量在类的外部定义和初始化，而不是在类的内部或对象的上下文中。</li>
</ul>
<h3>2. 使用 <code>new</code>​ 的问题</h3>
<ul>
<li>
<p>当你使用 <code>new int counter;</code>​ 时，你是在动态分配内存，并创建一个新的 <code>int</code>​ 类型的变量。这样做会导致每个对象都有自己独立的 <code>counter</code>​ 变量，不再是共享的静态成员。</p>
</li>
<li>
<p>因为 <code>counter</code>​ 是静态的，应该在类的外部进行定义和初始化，如：<br />
cpp</p>
<p>Copy</p>
<pre><code>int Car::counter = 0; // 在类外进行初始化
</code></pre>
</li>
</ul>
<h2>指针</h2>
<ul>
<li>​<strong>​<code>A *const p</code>​</strong>​：指针不变，内容可变。</li>
<li>​<strong>​<code>const A *const p</code>​</strong>​：指针不变，内容不可变。</li>
<li>​<strong>​<code>const A *p</code>​</strong>​：指针可变，内容不可变。</li>
</ul>
<p>　　‍</p>
<h2>虚拟继承</h2>
<h3>例子：虚拟继承的实现</h3>
<p>　　下面是一个功能完整的示例，展示了如何使用虚拟继承：</p>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code class="language-cpp">#include <iostream>

// 基类
class Base {
public:
    Base() { std::cout << &quot;Base constructor called\n&quot;; }
    void showValue() { std::cout << &quot;Value: &quot; << value << &quot;\n&quot;; }
    int value = 42;
};

// 虚拟继承的派生类
class Derived1 : public virtual Base {
public:
    Derived1() { std::cout << &quot;Derived1 constructor called\n&quot;; }
};

class Derived2 : public virtual Base {
public:
    Derived2() { std::cout << &quot;Derived2 constructor called\n&quot;; }
};

// 最终派生类
class MostDerived : public Derived1, public Derived2 {
public:
    MostDerived() { std::cout << &quot;MostDerived constructor called\n&quot;; }
};

int main() {
    MostDerived obj;  // 创建 MostDerived 对象
    obj.showValue();  // 访问 Base 的方法

    return 0;
}
</code></pre>
<h3>输出</h3>
<p>　　运行以上代码会得到如下输出：</p>
<pre><code class="language-delphi">Base constructor called
Derived1 constructor called
Derived2 constructor called
MostDerived constructor called
Value: 42
</code></pre>
<h3>解释</h3>
<ol>
<li>
<p><strong>构造顺序</strong>：</p>
<ul>
<li>当创建 <code>MostDerived</code>​ 对象时，首先调用基类 <code>Base</code>​ 的构造函数，接着是 <code>Derived1</code>​ 和 <code>Derived2</code>​ 的构造函数，最后是 <code>MostDerived</code>​ 的构造函数。</li>
<li>由于使用了虚拟继承，<code>Base</code>​ 只被构造一次。</li>
</ul>
</li>
<li>
<p><strong>只有一个</strong> <strong>​<code>Base</code>​</strong>​ <strong>实例</strong>：</p>
<ul>
<li>虚拟继承确保 <code>MostDerived</code>​ 只会有一个 <code>Base</code>​ 的实例。无论 <code>Derived1</code>​ 和 <code>Derived2</code>​ 各自如何继承 <code>Base</code>​，在 <code>MostDerived</code>​ 中，只有一个 <code>Base</code>​ 对象存在。</li>
<li>​<code>MostDerived</code>​ 通过 <code>Derived1</code>​ 和 <code>Derived2</code>​ 访问 <code>Base</code>​ 的成员，但实际上它访问的是同一个 <code>Base</code>​ 实例。</li>
</ul>
</li>
<li>
<p><strong>功能展示</strong>：</p>
<ul>
<li>通过调用 <code>obj.showValue()</code>​，可以访问 <code>Base</code>​ 的成员，显示 <code>value</code>​ 的值，证明 <code>MostDerived</code>​ 确实拥有一个有效的 <code>Base</code>​ 实例。</li>
</ul>
</li>
</ol>
<h3>总结</h3>
<ul>
<li>虚拟继承允许派生类共享基类的单一实例，避免冗余和二义性。</li>
<li>在 <code>MostDerived</code>​ 中，<code>Base</code>​ 的实例来自于 <code>Derived1</code>​ 和 <code>Derived2</code>​，但由于虚拟继承，它们共享同一个实例。</li>
</ul>
<p>　　‍</p>
<h2>抽象类</h2>
<p>　　抽象类是 C++ 中的一种特殊类，主要用于定义接口和规范。以下是关于抽象类的一些关键点：</p>
<h3>1. 定义</h3>
<ul>
<li><strong>抽象类</strong> 是至少包含一个 <strong>纯虚函数</strong> 的类。纯虚函数是一种在基类中声明但不提供实现的虚函数，形式为 <code>virtual void functionName() = 0;</code>​。</li>
</ul>
<h3>2. 特点</h3>
<ul>
<li><strong>不能实例化</strong>：抽象类不能直接创建对象。你不能像其他类那样实例化抽象类。</li>
<li><strong>用于派生</strong>：通常，抽象类是用作其他类的基类（派生类）。派生类必须实现所有的纯虚函数才能成为具体类（可以实例化的类）。</li>
</ul>
<h3>3. 用途</h3>
<ul>
<li><strong>定义接口</strong>：抽象类可以定义一个公共接口，确保所有派生类都实现特定的功能。</li>
<li><strong>代码重用</strong>：可以在抽象类中实现一些通用的功能，派生类可以直接使用。</li>
</ul>
<h3>4. 示例</h3>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code class="language-cpp">class Shape { // 抽象类
public:
    virtual void draw() = 0; // 纯虚函数
};

class Circle : public Shape { // 派生类
public:
    void draw() override { // 实现纯虚函数
        // 绘制圆的代码
    }
};

class Square : public Shape { // 另一个派生类
public:
    void draw() override { // 实现纯虚函数
        // 绘制方的代码
    }
};

int main() {
    Shape* shape1 = new Circle(); // 创建 Circle 对象
    shape1->draw(); // 调用 Circle 的 draw 方法

    Shape* shape2 = new Square(); // 创建 Square 对象
    shape2->draw(); // 调用 Square 的 draw 方法

    delete shape1;
    delete shape2;
    return 0;
}
</code></pre>
<h3>5. 总结</h3>
<ul>
<li>抽象类是一种用于定义接口的工具，不能直接实例化，但可以通过派生类实现具体的功能。它帮助程序员在设计类时保持一致性和可扩展性。</li>
</ul>
<h3>另一个示例：使用抽象类的引用</h3>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code>#include <iostream>
using namespace std;

// 抽象类
class Shape {
public:
    virtual void draw() = 0; // 纯虚函数
};

// 派生类：圆形
class Circle : public Shape {
public:
    void draw() override {
        cout << &quot;Drawing a Circle&quot; << endl;
    }
};

// 派生类：正方形
class Square : public Shape {
public:
    void draw() override {
        cout << &quot;Drawing a Square&quot; << endl;
    }
};

// 函数，接受 Shape 的引用
void renderShape(Shape& shape) {
    shape.draw(); // 调用具体的绘制方法
}

int main() {
    Circle circle;
    Square square;

    // 使用引用来调用
    renderShape(circle); // 输出 &quot;Drawing a Circle&quot;
    renderShape(square); // 输出 &quot;Drawing a Square&quot;

    return 0;
}
</code></pre>
<h3>函数定义及调用</h3>
<ul>
<li>在函数 <code>renderShape(Shape& shape)</code>​ 中，<code>Shape&</code>​ 表示参数 <code>shape</code>​ 是一个对 <code>Shape</code>​ 类型的引用。这意味着你可以直接传递一个 <code>Shape</code>​ 类型的对象（或其派生类的对象），而无需使用指针。</li>
<li>当调用 <code>renderShape(circle)</code>​ 时，<code>circle</code>​ 是 <code>Circle</code>​ 类的对象。由于 <code>Circle</code>​ 继承自 <code>Shape</code>​，你可以将 <code>circle</code>​ 对象传递给 <code>renderShape</code>​ 函数。C++ 会自动将 <code>circle</code>​ 对象的引用传递给 <code>shape</code>​ 参数。</li>
</ul>
<h3>示例分析</h3>
<p>　　cpp</p>
<p>　　Copy</p>
<pre><code>void renderShape(Shape& shape) {
    shape.draw(); // 调用具体的绘制方法
}
</code></pre>
<ul>
<li>这里 <code>shape</code>​ 是一个引用，指向传入的对象（例如 <code>circle</code>​ 或 <code>square</code>​）。</li>
<li>由于 <code>shape</code>​ 是一个引用，可以直接调用 <code>draw()</code>​ 方法，而不需要使用 <code>-></code>​ 运算符。</li>
</ul>
<h3>总结</h3>
<ul>
<li>使用引用的好处是让代码更简洁，避免了指针的复杂性，同时也避免了指针可能出现的空指针问题。</li>
<li>通过引用，你可以像使用普通对象一样使用形参，而不需要明确地解引用它。</li>
</ul>
<p>　　因此，<code>renderShape(circle)</code>​ 可以直接使用对象 <code>circle</code>​，而不是使用指针。这使得代码更易于阅读和维护。</p>
<h3>三元运算符的语法</h3>
<pre><code class="language-cpp">condition ? expression1 : expression2
</code></pre>
<h3>组成部分</h3>
<ol>
<li>
<p><strong>condition</strong>（条件）：</p>
<ul>
<li>这是一个布尔表达式，返回 <code>true</code>​ 或 <code>false</code>​。</li>
<li>例如，<code>a > b</code>​。</li>
</ul>
</li>
<li>
<p><strong>expression1</strong>（真值表达式）：</p>
<ul>
<li>如果条件为 <code>true</code>​，则返回这个表达式的值。</li>
<li>例如，<code>a</code>​。</li>
</ul>
</li>
<li>
<p><strong>expression2</strong>（假值表达式）：</p>
<ul>
<li>如果条件为 <code>false</code>​，则返回这个表达式的值。</li>
<li>例如，<code>b1</code>​。</li>
</ul>
</li>
</ol>
<h2>文档类和视图类</h2>
<p>　　在MFC（Microsoft Foundation Classes）中，文档类和视图类是实现应用程序的核心组件，它们之间的关系是基于MVC（Model-View-Controller）设计模式的。以下是它们之间的主要关系和功能：</p>
<h3>1. 文档类（CDocument）</h3>
<ul>
<li>
<p><strong>定义</strong>：文档类负责管理应用程序的数据和状态。它通常包含应用程序的核心数据结构和逻辑。</p>
</li>
<li>
<p><strong>功能</strong>：</p>
<ul>
<li>数据管理：存储和管理应用程序的数据（如文件内容、用户输入等）。</li>
<li>数据持久化：处理数据的读写，包括文件的打开、保存和关闭。</li>
<li>更新通知：在数据发生变化时，通知视图类更新显示。</li>
</ul>
</li>
</ul>
<h3>2. 视图类（CView）</h3>
<ul>
<li>
<p><strong>定义</strong>：视图类负责显示文档类中的数据。每个文档可以有多个视图，视图类渲染文档数据并处理用户输入。</p>
</li>
<li>
<p><strong>功能</strong>：</p>
<ul>
<li>数据展示：将文档中的数据以图形或文本的形式展现给用户。</li>
<li>用户输入处理：响应用户的操作（如鼠标点击、键盘输入等），并可能更新文档中的数据。</li>
<li>更新显示：根据文档的变化，更新自身显示的内容。</li>
</ul>
</li>
</ul>
<h3>3. 互相关系</h3>
<ul>
<li>
<p><strong>一对多关系</strong>：一个文档类对象通常可以对应多个视图类对象。这样，用户可以通过不同的视图来查看同一份文档数据。</p>
</li>
<li>
<p><strong>消息传递</strong>：</p>
<ul>
<li>当文档中的数据发生变化时，文档类使用<code>UpdateAllViews</code>​方法通知所有关联的视图类进行更新。</li>
<li>视图类在处理用户输入时，可以通过调用文档类的方法来修改数据。</li>
</ul>
</li>
</ul>
<p>　　‍</p>
