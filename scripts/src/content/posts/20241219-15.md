---
title: "STM32-GPIO"
published: 2024-12-19
tags: []
category: "嵌入式STM32"
draft: false
---
<h1>GPIO</h1>
<ol>
<li>首先了解一下GPIO是什么？</li>
</ol>
<ul>
<li><strong>GPIO</strong>（英语：General-purpose input/output），通用型之输入输出的简称，用于电信号在电路中的输入输出，以方便控制电路部件。</li>
</ul>
<ol start="2">
<li>然后了解一下GPIO的四种功能：</li>
</ol>
<ul>
<li>
<p>4种输入模式：</p>
<ul>
<li>输入浮空IN_FLOATING</li>
<li>输入上拉IPD</li>
<li>输入下拉IPU</li>
<li>模拟输入AIN</li>
</ul>
</li>
<li>
<p>4种输出模式：</p>
<ul>
<li>开漏输出</li>
<li>开漏复用功能</li>
<li>推挽式输出</li>
<li>推挽式复用功能</li>
</ul>
</li>
<li>
<p>3种最大输出速度：</p>
<ul>
<li>2MHZ</li>
<li>10MHZ</li>
<li>50MHZ</li>
</ul>
</li>
</ul>
<ol start="3">
<li>最后是如果控制GPIO？</li>
</ol>
<p>　　控制GPIO是通过调用寄存器实现的，每组IO口含下面7个寄存器。也就是7个寄存器，一共可以控制一组GPIO的16个IO口。</p>
<ul>
<li>GPIOx_CRL :端口配置低寄存器</li>
<li>GPIOx_CRH:端口配置高寄存器</li>
<li>GPIOx_IDR:端口输入寄存器</li>
<li>GPIOx_ODR:端口输出寄存器</li>
<li>GPIOx_BSRR:端口位设置/清除寄存器</li>
<li>GPIOx_BRR :端口位清除寄存器</li>
<li>GPIOx_LCKR:端口配置锁存寄存器</li>
</ul>
<hr />
<p>　　我将在正文中以STM32F103ZET为例子，对GPIO做一个较为详细的整理。</p>
<h2><strong>正文</strong></h2>
<p>　　对于STM32F103ZET： 共七组IO口，每组IO口有十六个IO，共112个IO口</p>
<p>　　这七组IO口分别命名为GPIOA，GPIOB，GPIOC，GPIOD，GPIOE，GPIOH，而每组又有十六个端口，分别以0~15来命名，例如GPIOA_1,GPIOA_2。</p>
<h2>八种GPIO工作模式：</h2>
<ol>
<li>浮空模式，顾名思义就是浮在空中,上面用绳子一拉就上去了,下面用绳子一拉就沉下去了.</li>
<li>开漏模式，就等于输出口接了个NPN三极管,并且只接了e,b. c极 是开路的,你可以接一个电阻到 3.3V,也可以接一个电阻到5V,这样,在输出1的时候,就可以是5V电压,也可以是3. 3V电压了。但是不接电阻上拉的时候,这个输出高就不能实现了.</li>
<li>推挽模式，就是有推有拉,任何时候IO口的电平都是确定的,不需要外接上拉或者下拉电阻.</li>
</ol>
<p>　　（1）GPIO_Mode_AIN 模拟输入</p>
<p>　　（2）GPIO_Mode_IN_FLOATING 浮空输入</p>
<p>　　（3）GPIO_Mode_IPD 下拉输入</p>
<p>　　（4）GPIO_Mode_IPU 上拉输入</p>
<p>　　（5）GPIO_Mode_Out_OD 开漏输出</p>
<p>　　（6）GPIO_Mode_Out_PP 推挽输出</p>
<p>　　（7）GPIO_Mode_AF_OD 复用开漏输出（第二功能IO口）</p>
<p>　　（8）GPIO_Mode_AF_PP 复用推挽输出（第二功能IO口）</p>
<p>　　推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中，各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。</p>
<ol start="4">
<li>开漏输出模式，输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。</li>
</ol>
<p>　　开漏形式的电路有以下四个特点：</p>
<ol>
<li>利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。</li>
<li>一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的沿的速度 。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。）</li>
<li>OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。</li>
<li>可以将多个开漏输出的IO口，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。其中大家对于线与逻辑比较生疏，线与逻辑即两个输出端（包括两个以上）直接互连就可以实现“AND”的逻辑功能。</li>
</ol>
<p>　　浮空输入状态下，就是指IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的，就像是薛定谔的猫，这种情况也被称为高阻态。</p>
<p>　　上拉输入/下拉输入/模拟输入：这几个概念很好理解，从字面便能轻易读懂。</p>
<p>　　复用开漏输出、复用推挽输出：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p>
<p>　　最后总结下使用情况：</p>
<p>　　在STM32中选用IO模式</p>
<p>　　（1） 浮空输入_IN_FLOATING ——浮空输入，可以做KEY识别，RX1</p>
<p>　　（2）带上拉输入_IPU——IO内部上拉电阻输入</p>
<p>　　（3）带下拉输入_IPD—— IO内部下拉电阻输入</p>
<p>　　（4） 模拟输入_AIN ——应用ADC模拟输入，或者低功耗下省电</p>
<p>　　（5）开漏输出_OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能</p>
<p>　　（6）推挽输出_OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的</p>
<p>　　（7）复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA）</p>
<p>　　（8）复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）</p>
<h2>STM32设置实例：</h2>
<p>　　（1）模拟I2C使用开漏输出_OUT_OD，接上拉电阻，能够正确输出0和1；</p>
<p>　　读值时先GPIO_SetBits(GPIOB, GPIO_Pin_0)；</p>
<p>　　拉高，然后可以读IO的值，使用GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)；</p>
<p>　　（2）如果是无上拉电阻，IO默认是高电平；需要读取IO的值，可以使用带上拉输入_IPU和浮空输入_IN_FLOATING和开漏输出_OUT_OD；</p>
<h2>TTL肖特基触发器：</h2>
<p>　　TTL肖特基触发器：可将一些模拟信号最终转化为数字信号。</p>
<p>　　它有三个作用：</p>
<p>　　1．用于波形变换</p>
<p>　　三角波、正弦波及其它不规则信号→矩形脉冲。</p>
<p>　　所示为用施密特触发器将正弦波变换成同周期的矩形脉冲。</p>
<p>　　2．用于脉冲整形</p>
<p>　　当传输的信号受到干扰而发生畸变时，可利用施密特触发器的回差特性，将受到干扰的信号整形成较好的矩形脉冲，</p>
<p>　　3．用于脉冲幅度鉴别</p>
<p>　　如输入信号为一组幅度不等的脉冲，可将输入幅度大于 的脉冲信号选出来，而幅度小 的脉冲信号则去掉了。</p>
<p>　　最后展示GPIO的基本结构图：</p>
<p>​<img src="https://pica.zhimg.com/v2-bd05d41918b7609ab31f275c535e046a_r.jpg" alt="" />​</p>
<p>　　GPIO的基本结构图</p>
